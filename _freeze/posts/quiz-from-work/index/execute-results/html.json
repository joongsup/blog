{
  "hash": "7f3577069c3ebcdf81eb183a4317020b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Quiz from work\ndate: '2018-02-01'\ndraft: false\n---\n\n\n\n> There are 25 black balls and 25 white balls in a jar. We take two balls at random from the jar, and the one of the three: (1)  if two black balls are drawn, put them back in to the jar; (2) if two white balls are drawn, throw them away; (3) if mixed, put a white ball back in, and throw away the black ball. We win this game when a white ball is the only ball remaining in the jar. Can we win the game, and if yes, what's the probability that we win the game?\n\nSince this quiz was asked in a \"coding challenge\" session at work, I went ahead and wrote the following to see what happens, even though I suspected this could be solved with pen/paper, especially because the quiz was introduced as a question that had been asked at a job interview. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndraw_balls <- function(balls){ # balls = list(begin_w, begin_b)\n  w <- balls[[1]]\n  b <- balls[[2]]\n  #print(paste0(\"Beginning balls (w, b): \", w, \", \", b))\n  \n  # note I'm assuming two balls are drawn one at a time, not together\n  # other drawing rules are possible\n  # drawing rule for first ball\n  if (runif(1) < w/(w + b)) {\n    wtmp1 <- 1 # draw white\n    btmp1 <- 0\n  } else {\n    wtmp1 <- 0\n    btmp1 <- 1 # draw black\n  }\n      \n  # drawing rule for second ball\n  if (runif(1) < (w - wtmp1)/(w - wtmp1 + b - btmp1)){\n    wtmp2 <- 1 # draw white\n    btmp2 <- 0\n  } else {\n    wtmp2 <- 0\n    btmp2 <- 1 # draw black\n  } \n      \n  # post-draw actions\n \n  if (wtmp1 == 1 & wtmp2 == 1) {\n    #print(\"Balls drawn: 2 W\")\n    w <- w - (wtmp1 + wtmp2)\n    b <- b\n  } else if (btmp1 == 1 & btmp2 == 1){\n    #print(\"Balls drawn: 2 B\")\n    w <- w\n    b <- b\n  } else { # if mixed\n    #print(\"Balls drawn: mixed\")\n    w <- w\n    b <- b - 1\n  }\n\n  #print(paste0(\"Ending balls (w, b): \", w, \", \", b))\n  balls <- list(ending_w = w, ending_b = b)\n}\n\n# stopping rule1: if whilte ball = 0, black balls >= 1; then white loses\n# stopping rule2: if black ball = 0, white ball odd numbers are left; then white wins\n# stopping rule3: if black ball = 0, white ball even numbers are left; then white loses\n\niterate_draw_balls <- function(count = 0, begin_w, begin_b){\n\n  while(begin_w * begin_b > 0){\n    #print(\"==============================\")\n    count <- count + 1\n    #print(paste0(\"Count: \", count))\n    \n    a <- draw_balls(list(begin_w, begin_b))\n    begin_w <- a$ending_w\n    begin_b <- a$ending_b\n  }\n\n  \n  if (begin_w == 0){ # stopping rule 1\n    win <- 0\n    #print(\"The last ball was a black one\")\n    win\n  } else if (begin_w %% 2 == 1) { # stopping rule 2\n    win <- 1\n    #print(\"The last ball was a white one.\")\n    win\n  } else if (begin_w %% 2 == 0) { # stopping rule 3\n    win <- 0\n    #print(\"There is no ball left.\")\n    win\n  } else {\n    #print(\"Shouldn't see this!\")\n    win <- -9999999999\n  }\n}\n\n#--------------------------------\n# run the monte carlo simulation\n#--------------------------------\n\nset.seed(1234)\nN <- 100\nbegin_w <- 25\nbegin_b <- 25\nresults <- vector(\"list\", length = N)\nfor (sim in 1:N){\n  #print(paste0(\"Simulation iteration: \", sim))\n  results[[sim]] <- iterate_draw_balls(count = 0, begin_w = begin_w, begin_b = begin_b)\n  #print(paste0(\"Simulation result: \", results[[sim]]))\n}\nsum(unlist(results))/N\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\nFor different values of N, the results were the same, depending on whether the number of white balls was odd or even. So the immediate answer to the quiz seems to be that we always win, since we started the game with 25 white balls. \n\nSeeing such pattern, I thought about state space of white and black balls in terms of them being odd or even, and after tinkering with different transition cases, it confirmed my simulation experiment. \n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}